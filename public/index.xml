<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>X-Factor CNFs</title>
    <link>http://example.org/</link>
    <description>Recent content on X-Factor CNFs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>http://example.org/build-release-run/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/build-release-run/</guid>
      <description>V. Build, release, run Strictly separate build and run stages A codebase is transformed into a (non-development) deploy through three stages:
 The build stage is a transform which converts a code repo into an executable bundle known as a build. Using a version of the code at a commit specified by the deployment process, the build stage fetches vendors dependencies and compiles binaries and assets. The release stage takes the build produced by the build stage and combines it with the deploy&amp;rsquo;s current config.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/concurrency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/concurrency/</guid>
      <description>VIII. Concurrency Scale out via the process model Any computer program, once run, is represented by one or more processes. Apps have taken a variety of process-execution forms. For example, PHP processes run as child processes of Apache, started on demand as needed by request volume. Java processes take the opposite approach, with the JVM providing one massive uberprocess that reserves a large block of system resources (CPU and memory) on startup, with concurrency managed internally via threads.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/config/</guid>
      <description>III. Config Store config in the environment A CNF&amp;rsquo;s config is everything that is likely to vary between deploys (staging, production, developer environments, etc). This includes:
 Resource handles to the database, Memcached, and other backing services Credentials to external services such as Amazon S3 or Twitter Per-deploy values such as the canonical hostname for the deploy  CNFs sometimes store config as constants in the code. This is a violation of X-factor, which requires strict separation of config from code.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/dependencies/</guid>
      <description>II. Dependencies Explicitly declare and isolate dependencies Most programming languages offer a packaging system for distributing support libraries, such as CPAN for Perl or Rubygems for Ruby. Libraries installed through a packaging system can be installed system-wide (known as &amp;ldquo;site packages&amp;rdquo;) or scoped into the directory containing the app (known as &amp;ldquo;vendoring&amp;rdquo; or &amp;ldquo;bundling&amp;rdquo;).
A X-factor CNF never relies on implicit existence of system-wide packages. It declares all dependencies, completely and exactly, via a dependency declaration manifest.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/dev-prod-parity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/dev-prod-parity/</guid>
      <description>X. Dev/prod parity Keep development, staging, and production as similar as possible Historically, there have been substantial gaps between development (a developer making live edits to a local deploy of the CNF) and production (a running deploy of the CNF accessed by end users). These gaps manifest in three areas:
 The time gap: A developer may work on code that takes days, weeks, or even months to go into production.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/disposability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/disposability/</guid>
      <description>IX. Disposability Maximize robustness with fast startup and graceful shutdown The X-factor CNF&amp;rsquo;s processes are disposable, meaning they can be started or stopped at a moment&amp;rsquo;s notice. This facilitates fast elastic scaling, rapid deployment of code or config changes, and robustness of production deploys.
Processes should strive to minimize startup time. Ideally, a process takes a few seconds from the time the launch command is executed until the process is up and ready to receive requests or jobs.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/intro/</guid>
      <description>Introduction Cloud-Native Network Function (CNF) developers may learn much by studying how 12 Factor Apps are built. With X-Factor CNFs (X-CNF), we build on the lessons learned from building 12 Factor Apps.
Following these patterns will help guide you construct CNFs which are easier to develop, operate and maintain.
Like 12 Factor Apps, X-CNFs have the following properties:
 Use declarative formats for setup automation, to minimize time and cost for new developers joining the project; Have a clean contract with the underlying operating system, offering maximum portability between execution environments; Are suitable for deployment on modern cloud and service provider platforms, obviating the need for servers, virtual machines and systems administration; Minimize divergence between development and production, enabling continuous deployment for maximum agility; And can scale up without significant changes to tooling, architecture, or development practices.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/logs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/logs/</guid>
      <description>XI. Logs Treat logs as event streams Logs provide visibility into the behavior of a running CNF. In server-based environments they are commonly written to a file on disk (a &amp;ldquo;logfile&amp;rdquo;); but this is only an output format.
Logs are the stream of aggregated, time-ordered events collected from the output streams of all running processes and backing services. Logs in their raw form are typically a text format with one event per line (though backtraces from exceptions may span multiple lines).</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/mechanisms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/mechanisms/</guid>
      <description>XV. Interface mechanisms List mechanisms supported in order of preference A given X-factor CNF lists in order of preference what types of interface mechanisms are supported for both its terminating and initiating interfaces.
An interface mechanism is any serial/block device,, file or socket that is used to transport data in and out of the container. The most common type of interface mechanism is the Linux interface. Other common mechanisms include SR-IOV, vhost-user, shmem, unix sockets, or serial/block devices.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/metrics-as-event-streams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/metrics-as-event-streams/</guid>
      <description> XVII. Metrics Treat metrics as event streams Metrics should be treated as event streams. The Cloud-Native environment provides mature metric collection and visualization software suites designed to work with high frequency and high scale applications. Likewise, the X-factor CNF benefits from this shared ecosystem by making use of these Cloud-Native metrics systems.
TODO  Learn more about how metrics are captured in kubernetes and make guidance available here  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/metrics-as-logs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/metrics-as-logs/</guid>
      <description>XVII. Metrics Treat metrics as event streams Metrics should be treated as event streams. The Cloud-Native environment provides mature metric collection and visualization software suites designed to work with high frequency and high scale applications. Likewise, the X-factor CNF benefits from this shared ecosystem by making use of these Cloud-Native metrics systems.
The Cloud-Native environment streams data out via stdout</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/payloads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/payloads/</guid>
      <description>XIV. Payloads Explicitly state payload types produced and consumed X-factor CNFs explicity state what type of payloads they produce and consume. Each X-factor CNF consumes one payload type and produces one payload type.
CNFs consume payloads with a given type. X-factor CNFs define the payload types they produce and consume in their CNF metadata. These payloads are network protocols which the CNF is programmed to interact with. Common payloads include IP, Ethernet and MPLS.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/port-binding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/port-binding/</guid>
      <description>VII. Port binding Not recommended in X-factor CNFs. However, if necessary, export services via port binding Port binding has been removed from X-factor CNFs. Exposing services over the orchestration-managed network interface is not recommended.
However, if an X-factor CNF must provide a service over the orchestration-managed network interface, the X-factor CNF follows the same rules as a 12-factor app, as follows:
12-factor rule VII. Port binding Export services via port binding Web apps are sometimes executed inside a webserver container.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/process-containers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/process-containers/</guid>
      <description>XIII. Do not require kernel modifications or modules Run in an unmodified OS environment, without kernel modifications or custom modules X-factor CNFs are designed to run in process containers rather than VMs. To achieve this, custom kernel modifications and custom kernel modules are not allowed. Instead, X-factor CNfs run on commodity hardware with unmodified upstream kernels.
X-factor CNFs also recognize the need for hardware which requires additional kernel modules. These kernel modules must follow standard Linux kernel device driver standards (TODO find link) and do not affect the kernel&amp;rsquo;s runtime environment beyond enabling the device.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/processes/</guid>
      <description>VI. Processes Execute the app as one or more stateless processes The CNF is executed in the execution environment as one or more processes.
In the simplest case, the code is a stand-alone script, the execution environment is a developer&amp;rsquo;s local laptop with an installed language runtime, and the process is launched via the command line (for example, python my_script.py). On the other end of the spectrum, a production deploy of a sophisticated CNF may use many process types, instantiated into zero or more running processes.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/who/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/who/</guid>
      <description>Who should read this document? Any developer building Cloud-Native Network Functions. Ops engineers who deploy or manage such applications.</description>
    </item>
    
  </channel>
</rss>